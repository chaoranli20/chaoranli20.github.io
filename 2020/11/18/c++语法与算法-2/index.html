<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C&#x2F;C++快速入门前言 #include &lt;stdio.h&gt;是标准输入输出库，有输入输出就需要加这一行。 &lt;string.h&gt;负责字符串有关函数 c语言中的.h和c++中更推荐的写法#include &lt;cstdio&gt;以及#include &lt;cstring&gt;等等价">
<meta property="og:type" content="article">
<meta property="og:title" content="c++语法与算法-第二章">
<meta property="og:url" content="http://example.com/2020/11/18/c++%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95-2/index.html">
<meta property="og:site_name">
<meta property="og:description" content="C&#x2F;C++快速入门前言 #include &lt;stdio.h&gt;是标准输入输出库，有输入输出就需要加这一行。 &lt;string.h&gt;负责字符串有关函数 c语言中的.h和c++中更推荐的写法#include &lt;cstdio&gt;以及#include &lt;cstring&gt;等等价">
<meta property="og:locale">
<meta property="article:published_time" content="2020-11-18T10:34:13.000Z">
<meta property="article:modified_time" content="2020-12-05T12:55:40.910Z">
<meta property="article:author" content="superran">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/11/18/c++%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>c++语法与算法-第二章 | </title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title"></h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-本站首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>本站首页</a>

  </li>
        <li class="menu-item menu-item-关于我">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/18/c++%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="superran">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++语法与算法-第二章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-18 18:34:13" itemprop="dateCreated datePublished" datetime="2020-11-18T18:34:13+08:00">2020-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-05 20:55:40" itemprop="dateModified" datetime="2020-12-05T20:55:40+08:00">2020-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">计算机语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C-C-快速入门"><a href="#C-C-快速入门" class="headerlink" title="C/C++快速入门"></a>C/C++快速入门</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>#include &lt;stdio.h&gt;是标准输入输出库，有输入输出就需要加这一行。</li>
<li>&lt;string.h&gt;负责字符串有关函数</li>
<li>c语言中的.h和c++中更推荐的写法#include &lt;cstdio&gt;以及#include &lt;cstring&gt;等等价<a id="more"></a></li>
<li>%d是int型的输入输出标识，%f是float的输入输出格式，%c是char型的输入输出格式，%s是字符串常量的输入输出格式，”%.1f”指保留一位小数输出，%lld是long long的输入输出格式，%lf是double的输入格式，%f是都double的输出格式；</li>
<li>%c能识别空格和换行并把它们输入，%s通过空格或换行来识别一个字符串的结束</li>
</ul>
<h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul>
<li>变量名第一个字符可以是字母或者下划线</li>
<li>任何一个变量在使用或者是赋值之前必须要声明类型</li>
<li>整型<ul>
<li>int占32位，绝对值在10E09范围内的整数或32位二进制整数都可定义为int;</li>
<li>long long占64位，绝对值10E18内或64位二进制整数，如果赋大于int取值范围的初值，初值后面要加LL；</li>
<li>unsigned int和unsigned long long占用的位数相同，但把负数挪到正数上来了；</li>
</ul>
</li>
<li>浮点型<ul>
<li>单精度float，32位，其中1位符号位，8位指数位，23位尾数位，可存放-2E128——+2E128的浮点数，但其有效精度只有6-7位；</li>
<li>双精度double，64位，其中1位符号位，11位指数位，52位尾数位，可存放-2E1024——+2E1024的浮点数，但其有效精度为15-16位；</li>
<li>遇到浮点型的数据都应该用double来存储以保证精度；</li>
</ul>
</li>
<li>字符型<ul>
<li>定义方式：char c = ‘e’;</li>
<li>C语言中字符常量使用ASCII码统一编码，范围为0-127，小写字母比大写字母的ASCII码大32；</li>
<li>字符常量必须用<strong>单引号</strong>标注</li>
<li>下面的写法是可以的，因为117是u的ASCII码；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出结果为c</span><br><span class="line">char c &#x3D; 117;</span><br><span class="line">printf(&quot;%c&quot;, c);</span><br></pre></td></tr></table></figure></li>
<li>转义字符：“\n”表示换行。“\0”表示空字符NULL，ASCII码为0，注意这不是空格；</li>
<li>下面代码的输出为1下面空一行，再下面是2，然后电脑会响一声，因为ASCII码为7的字符是控制字符控制响铃；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n\n%d&quot;, 1, 2);</span><br><span class="line">printf(&quot;%c&quot;, 7);</span><br></pre></td></tr></table></figure></li>
<li>C语言中没有基本数据类型可以存储字符串，只能用字符数组的方式，C++中有string类型；</li>
<li>字符串常量用<strong>双引号</strong>标注</li>
<li>字符串常量可以作为初值赋给字符数组，不能赋给字符变量；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str1[25] &#x3D; &quot;wo ai de ren bu ai wo&quot;;</span><br><span class="line">char str2[25] &#x3D; &quot;so sad a story&quot;;</span><br><span class="line">printf(&quot;%s, %s&quot;, str1, str2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>布尔型<ul>
<li>定义方式：bool flag1 = true, flag2 = -1;//计算机识别为flag1和flag2都为true；</li>
<li>在c++中可以直接使用，但在c语言中必须添加&lt;stdbool.h&gt;才可以使用；</li>
<li>取值只能是true或者false，计算机分别存储为1和0，使用%d输出时会输出1和0；</li>
<li>可以使用true和false直接赋值或者使用整型常量赋值，但只有0才会被识别并自动转换为false；</li>
</ul>
</li>
</ul>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li>有时整型需要变为浮点型方便做除法，因为整数除以整数在计算机中视为整除，不会自动变为浮点数；如下面输出结果都为0.00，编译器出错；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%f %f&quot;, 3&#x2F;2, 3);</span><br></pre></td></tr></table></figure></li>
<li>格式为(新类型名)变量名；</li>
<li>类型间变量赋值时如果没有写强制类型转换，编译器会自动转换。但如果计算过程中需要转化类型，就不能算完再赋值，例如下面两行输出分别为0和0.6；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;, (double)(a &#x2F; b));</span><br><span class="line">printf(&quot;%.1f&quot;, (double)a &#x2F; (double)b);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="符号常量和const常量"><a href="#符号常量和const常量" class="headerlink" title="符号常量和const常量"></a>符号常量和const常量</h3><ul>
<li>符号常量即用标识符来替代常量，又称为宏定义或者宏替换，在程序执行前全部自动把标识符替换为常量；</li>
<li>define和const都在头文件处定义，更推荐const的写法；</li>
<li>两种写法都一旦确定就不能改变，如#define pi 3.14后不能再写pi = pi + 1；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 符号常量格式为#define 标识符 常量</span><br><span class="line">#define pi 3.14</span><br><span class="line">&#x2F;&#x2F; const常量格式为const 数据类型 变量名&#x3D;变量；</span><br><span class="line">const double pi &#x3D; 3.14;</span><br></pre></td></tr></table></figure></li>
<li>define不仅可以定义常量，也可以定义任意语句或片段，但要注意加括号，因为define是直接替换；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ADD(a, b) ((a) + (b))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算术运算符<ul>
<li>+-*/(双整数时取商)%(双整数时取模，不能用于浮点数)++–</li>
<li>除数如果是0会导致异常退出或得到错误输出“1.#INF00”</li>
<li>取模优先级和除法相同</li>
</ul>
</li>
<li>关系运算符<ul>
<li>&lt; &gt; &lt;= &gt;= == !=</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>&amp;&amp; || !!分别为与或非</li>
</ul>
</li>
<li>条件运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A如果为真，执行并返回B的结果，否则执行并返回C的结果</span><br><span class="line">A ? B : C;</span><br></pre></td></tr></table></figure></li>
<li>位运算符<ul>
<li>位运算符共六种，优先级没有算术运算符高；</li>
<li>由于int上限为2E31-1，所以程序中表示无穷大的数INF可以设置为(1&lt;&lt;31)-1，不过更常用的是(1&lt;&lt;30)-1即2E30-1，因为它可以避免相加超过int；</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">语法</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">a&lt;&lt;x</td>
<td align="center">整数a按二进制左移x位</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">位与</td>
<td align="center">a&amp;b</td>
<td align="center">整数a和b按二进制对齐按位进行与运算</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">位或</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">位异或</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">位取反</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>- 以下两个式子等价</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int INF &#x3D; (1 &lt;&lt; 30) - 1;</span><br><span class="line">const int INF &#x3D; 0x3fffffff;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-顺序结构"><a href="#2-2-顺序结构" class="headerlink" title="2.2 顺序结构"></a>2.2 顺序结构</h2><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><ul>
<li>可以连等，但不能在同一行既声明变量又连等；</li>
</ul>
<h3 id="使用scanf和printf输入和输出"><a href="#使用scanf和printf输入和输出" class="headerlink" title="使用scanf和printf输入和输出"></a>使用scanf和printf输入和输出</h3><ul>
<li>C语言中变量定义后会在内存中分配空间给这个变量，为了得到变量的地址需要在变量前加一个&amp;，但是char数组不需要，因为数组名称本身就代表了这个数组第一个元素的地址。</li>
<li>除要求char格式的输入外，scanf要求其他格式的输入时以空格换行等作为一个输入结束的标志。</li>
<li>字符数组使用%s读入时以空格和换行作为读入结束的标志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; scanf的格式为scanf(&quot;格式控制&quot;, 变量地址)，表示用户输入一个指定格式的变量，把它存到变量n中；</span><br><span class="line">&#x2F;&#x2F; printf的格式为printf(&quot;格式控制&quot;, 变量名称)</span><br><span class="line">scanf(&quot;%d:%d:%d&quot;, &amp;hour, &amp;minute, &amp;second)</span><br><span class="line">printf(&quot;%%&quot;); &#x2F;&#x2F; 输出百分号</span><br><span class="line">printf(&quot;\\&quot;); &#x2F;&#x2F; 输出\</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输入1 a bcd时，程序的输出为a &#x3D; %d, c &#x3D; , str &#x3D; a，因为%c可以读入空格与换行</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a;</span><br><span class="line">	char c, str[10];</span><br><span class="line">	scanf(&quot;%d%c%s&quot;, &amp;a, &amp;c, str);</span><br><span class="line">	printf(&quot;a &#x3D; %d, c &#x3D; %c, str &#x3D; %s&quot;, a, c, str);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实用输出格式<ul>
<li>%md可以使不足m位的int型变量以m位进行右对齐输出，高位空格补齐，变量本身超过m位时保持原样（但是此时所有变量并不是右对齐输出）；</li>
<li>%0md规则和%md相同，唯一的不同点在于变量不足m位时用0补足而不是空格；</li>
<li>%.mf让浮点数保留m位小数输出，此处保留的规则是四舍六入五成双，如果四舍五入需要使用round函数；</li>
</ul>
</li>
</ul>
<h3 id="使用getchar和putchar输入输出字符"><a href="#使用getchar和putchar输入输出字符" class="headerlink" title="使用getchar和putchar输入输出字符"></a>使用getchar和putchar输入输出字符</h3><ul>
<li>getchar()输入单个字符，putchar()输出单个字符，getchar()可以接收输入但不把它存储在常量中，getchar()可以识别并存储换行符；</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>/**/可以注释若干连续行的内容</li>
<li>//注释在该符号之后的内容，效果仅限该行</li>
</ul>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><ul>
<li>给复杂的数据类型起别名来代替原来的写法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef long long LL; &#x2F;&#x2F; 之后可以用LL代替long long</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="常用math函数"><a href="#常用math函数" class="headerlink" title="常用math函数"></a>常用math函数</h3><ul>
<li>使用时需要在程序开头加上math.h文件</li>
<li>fabs(double x)用于对double型变量取绝对值，实际使用时不需要写double，下同</li>
<li>floor(double x)和ceil(double x)分别对double型变量向上取整和向下取整，返回类型为double</li>
<li>pow(double r, double p)用于返回r^p</li>
<li>sqrt(double x)用于返回double类型的算术平方根</li>
<li>log(double x)用于返回double类型变量的以自然对数为底的对数<ul>
<li>c语言中没有对任意底数求对数的函数，必须使用换底公式计算，即log<sub>a</sub>b = log<sub>e</sub>b / log<sub>e</sub>a</li>
</ul>
</li>
<li>sin(double x), cos(double x), tan(double x), asin(double x), acos(double x), atan(double x)<ul>
<li>参数要求是弧度制，即sin45° = sin(pi * 45 / 180)，此处pi定义为acos(-1.0)</li>
</ul>
</li>
<li>round(double x)，用于把double型变量四舍五入为整数，返回类型也是double型变量，需要时要进行取整</li>
</ul>
<h2 id="2-3-选择结构"><a href="#2-3-选择结构" class="headerlink" title="2.3 选择结构"></a>2.3 选择结构</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 格式，else可不写，大括号中只有一个语句时可以去掉大括号</span><br><span class="line">if(条件A) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; else if(条件B) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>表达式是!=0时可以省略，直接写if(n)</li>
<li>表达式是==0时可以省略==0，在表达式前添加运算符!</li>
</ul>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">	case 常量表达式1:</span><br><span class="line">		...</span><br><span class="line">		break;</span><br><span class="line">	case 常量表达式n:</span><br><span class="line">		...</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果删掉break，程序会从第一个匹配的case开始执行语句直到下面所有语句都执行完毕。</li>
</ul>
<h2 id="2-4-循环结构"><a href="#2-4-循环结构" class="headerlink" title="2.4 循环结构"></a>2.4 循环结构</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果不加大括号，while循环只作用于while后的第一个分号前</span><br><span class="line">while(条件A)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;while(条件A);</span><br></pre></td></tr></table></figure>
<ul>
<li>do while的循环条件和while大部分情况下是一样的；</li>
</ul>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先执行A，若B成立则执行省略号内容否则退出循环，省略号内容执行完毕后执行C，再判断B，依此循环。</span><br><span class="line">&#x2F;&#x2F; for语句下只有一句时可以不加大括号</span><br><span class="line">for(表达式A; 表达式B; 表达式C)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>c语言不允许for语句的表达式1定义变量，例如int i的写法是不允许的，但在c++中可以</li>
</ul>
<h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><ul>
<li>break直接退出循环，continue结束循环当前轮回进入下一个轮回。</li>
</ul>
<h2 id="2-5-数组"><a href="#2-5-数组" class="headerlink" title="2.5 数组"></a>2.5 数组</h2><h3 id="2-5-1-一维数组"><a href="#2-5-1-一维数组" class="headerlink" title="2.5.1 一维数组"></a>2.5.1 一维数组</h3><ul>
<li>数组是从某个地址开始连续若干个位置形成的元素集合</li>
<li>数组大小必须是整数常量，不可是变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[10] &#x3D; &#123;5, 3, 2, 6, 8, 4&#125;;</span><br><span class="line">&#x2F;&#x2F; 如果想给整个数组都赋初值0，可以采取以下两种方式</span><br><span class="line">int a[10] &#x3D; &#123;0&#125;;</span><br><span class="line">int a[10] &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>数组中后一位的结果由前一位或若干位计算得来的做法称为递推，递推分为顺推和逆推</li>
</ul>
<h3 id="2-5-2-冒泡排序"><a href="#2-5-2-冒泡排序" class="headerlink" title="2.5.2 冒泡排序"></a>2.5.2 冒泡排序</h3><ul>
<li>每次通过交换把当前剩余元素的最大值移动到一端</li>
<li>整个过程执行n-1趟，每趟从左到右依次比较相邻的两个数</li>
</ul>
<h3 id="2-5-3-二维数组"><a href="#2-5-3-二维数组" class="headerlink" title="2.5.3 二维数组"></a>2.5.3 二维数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[5][6] &#x3D; &#123;&#123;3, 1, 2&#125;, &#123;8, 4&#125;, &#123;&#125;, &#123;1, 2, 3, 4, 5&#125;&#125;;</span><br><span class="line">&#x2F;&#x2F; 输出结果为</span><br><span class="line">3 1 2 0 0 0</span><br><span class="line">8 4 0 0 0 0</span><br><span class="line">0 0 0 0 0 0</span><br><span class="line">1 2 3 4 5 0</span><br><span class="line">0 0 0 0 0 0</span><br></pre></td></tr></table></figure>
<ul>
<li>如果数组大小较大（10<sup>6</sup>)，则需要把它定义在主函数外（定义后主函数中直接使用即可无需声明）否则会使程序异常退出，因为函数内部申请的局部变量来自系统栈，允许申请的空间较小</li>
<li>多维数组使用方法和二维数组基本无二</li>
</ul>
<h3 id="2-5-4-memset——对数组中每个元素赋相同的值"><a href="#2-5-4-memset——对数组中每个元素赋相同的值" class="headerlink" title="2.5.4 memset——对数组中每个元素赋相同的值"></a>2.5.4 memset——对数组中每个元素赋相同的值</h3><ul>
<li>使用memset需要在程序开头添加string.h头文件</li>
<li>只建议初学者使用memset赋0或-1，因为memset按字节赋值，对每个字节赋相同的值，0的二进制补码为全0，-1的二进制补码为全1，不易弄错，其他数字的赋值建议使用fill函数，虽然它比memset要慢<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;格式</span><br><span class="line">memset(数组名, 值, sizeof(数组名));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-5-5-字符数组"><a href="#2-5-5-字符数组" class="headerlink" title="2.5.5 字符数组"></a>2.5.5 字符数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符数组的初始化</span><br><span class="line">char str[15] &#x3D; &#123;&#39;G&#39;, &#39;O&#39;, &#39;O&#39;, &#39;D&#39;, &#39; &#39;, &#39;S&#39;, &#39;T&#39;, &#39;O&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;!&#39;&#125;;</span><br><span class="line">&#x2F;&#x2F; 也可以通过直接赋值字符串来初始化，但这样赋值仅限于初始化，程序其他位置不允许这样</span><br><span class="line">char str[15] &#x3D; &quot;Good Story!&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>char数组维度是二维时可以当做字符串数组，即若干字符串，字符数组的输入可以使用scanf，getchar，gets；输出可以使用printf，putchar，puts</li>
<li>getchar可以用于接收换行符</li>
<li>gets用于输入一行字符串，gets识别换行符\n作为输入结束，puts用于输出一行字符串，并紧跟一个换行</li>
<li>scanf和gets在一维字符数组和二维字符数组的第二维末尾都自动添加一个空字符\0，表示存放的字符串的结尾，puts和printf就是通过识别\0作为字符串的结尾来输出的<ul>
<li>\0的ASCII码为0，即空字符NULL，所以开字符数组时长度至少比实际字符串长度多1</li>
<li>int型数组末尾不需要加\0，只有char数组需要</li>
<li>空格的ASCII码是32，和\0不是一个东西，不要混淆</li>
<li>如果不是使用scanf的%s格式或者gets函数输入字符串（比如getchar），一定要手动在输入的每个字符串后加”\0”</li>
</ul>
</li>
</ul>
<h3 id="2-5-6-string-h头文件"><a href="#2-5-6-string-h头文件" class="headerlink" title="2.5.6 string.h头文件"></a>2.5.6 string.h头文件</h3><ul>
<li>包含了许多用于字符数组的函数</li>
<li>strlen()：得到字符数组第一个\0前的字符的个数，格式为strlen(字符数组)</li>
<li>strcmp(字符数组a, 字符数组b)：按字符串在字典中的顺序返回两个字符串大小比较结果，a&lt;b返回一个不一定是-1的负整数，相等返回0，a&gt;b返回一个不一定是+1的正整数</li>
<li>strcpy(字符数组a, 字符数组b)：把b复制给a，这里的复制包括了结束符\0</li>
<li>strcat(字符数组a, 字符数组b)：把b接到a后面</li>
</ul>
<h3 id="2-5-7-sscanf与spintf"><a href="#2-5-7-sscanf与spintf" class="headerlink" title="2.5.7 sscanf与spintf"></a>2.5.7 sscanf与spintf</h3><ul>
<li>都在stdio.h文件下</li>
<li>sscanf还支持正则表达式，配合正则表达式进行字符串处理，很多字符串题目会迎刃而解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 把字符数组str中的内容以%d的格式写到n中</span><br><span class="line">sscanf(str, &quot;%d&quot;, &amp;n)</span><br><span class="line">int n;</span><br><span class="line">double db;</span><br><span class="line">char str[100] &#x3D; &quot;2048:3.14,hello&quot;, str2[100];</span><br><span class="line">sscanf(str, &quot;%d:%lf,%s&quot;, &amp;n, &amp;db, str2);</span><br><span class="line">&#x2F;&#x2F; 把n以%d的格式写到字符数组str中</span><br><span class="line">sprintf(str, &quot;%d&quot;, n)</span><br><span class="line">int n &#x3D; 12;</span><br><span class="line">double db &#x3D; 3.1415;</span><br><span class="line">char str[100], str2[100] &#x3D; &quot;good&quot;;</span><br><span class="line">sprintf(str, &quot;%d:%lf,%s&quot;, n, db, str2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h2><h3 id="2-6-1-函数的定义"><a href="#2-6-1-函数的定义" class="headerlink" title="2.6.1 函数的定义"></a>2.6.1 函数的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名称(参数类型 参数)&#123;</span><br><span class="line">	函数主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>void可以不写return</li>
<li>定义在所有函数之前的变量是全局变量，在之后所有程序段内都有效</li>
<li>局部变量定义在函数内部，只在函数内部生效，函数定义的小括号内的参数为形参，实际调用函数时小括号内的参数称为实参</li>
<li>对计算机来说，main函数返回0的意义在于告知系统程序正常终止</li>
</ul>
<h3 id="2-6-3-以数组作为函数参数"><a href="#2-6-3-以数组作为函数参数" class="headerlink" title="2.6.3 以数组作为函数参数"></a>2.6.3 以数组作为函数参数</h3><ul>
<li>函数参数也可以是数组，数组做形参时，参数中数组的第一维不需要写长度，如果是二维数组，则第二维需要写长度；实际调用时，也只需要填写数组名</li>
<li>与普通局部变量不同，数组做参数时，在函数中对数组元素的修改等同于对原数组元素的修改</li>
<li>数组不允许作为返回类型出现，如果想返回数组，只能把想要返回的数组作为参数传入函数，或者可以设置全局变量</li>
</ul>
<h2 id="2-7-指针"><a href="#2-7-指针" class="headerlink" title="2.7 指针"></a>2.7 指针</h2><h3 id="2-7-1-什么是指针"><a href="#2-7-1-什么是指针" class="headerlink" title="2.7.1 什么是指针"></a>2.7.1 什么是指针</h3><ul>
<li>计算机中每个字节都会有一个地址，计算机通过地址找到某个变量，变量的地址一般指它占用的字节中第一个字节的地址</li>
<li>C语言中用指针表示或称指向内存地址，如果这个内存地址恰好是某个变量的地址，又称这个指针指向该变量</li>
<li>取地址运算符&amp;获得变量的地址，指针是一个unsigned类型的整数</li>
</ul>
<h3 id="2-7-2-指针变量"><a href="#2-7-2-指针变量" class="headerlink" title="2.7.2 指针变量"></a>2.7.2 指针变量</h3><ul>
<li>指针变量用来存放指针(或者可以理解为地址)</li>
<li>注意int*是指针变量的类型，p才是变量名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 在某种数据类型后加星号*来表示这是一个指针变量</span><br><span class="line">int* p;</span><br><span class="line"></span><br><span class="line"># 星号只会结合于第一个变量名，下面表示p1是int*型的，p2是int型的</span><br><span class="line">int* p1, p2;</span><br><span class="line"></span><br><span class="line"># 定义多个指针变量应该如下定义</span><br><span class="line">int *p1, *p2, *p3;</span><br><span class="line"></span><br><span class="line"># 给指针变量赋值方法如下</span><br><span class="line">int a;</span><br><span class="line">int* p &#x3D; &amp;a;</span><br><span class="line"></span><br><span class="line"># 或</span><br><span class="line">int a;</span><br><span class="line">int* p;</span><br><span class="line">p &#x3D; &amp;a;</span><br><span class="line"></span><br><span class="line"># 做如上定义后，p存放了a的地址，*p可以得到a，也可以对a进行赋值</span><br><span class="line">printf(&quot;%d\n&quot;, *p);</span><br><span class="line">*p &#x3D; 233;</span><br></pre></td></tr></table></figure></li>
<li>指针变量也可以进行加减法，减法的结果是两个地址偏移的距离(与数据类型大小有关，即两个int型指针相减等价于在求两个指针之间差几个int)，也支持自增自减操作，指针变量的加减法一般用于数组当中</li>
<li>对一个int*型的指针变量p，p+1指p所指的int型变量的下一个int型变量地址，即4字节后的地址</li>
<li>对指针变量而言，把其存储的地址的类型称为基类型，例如int* p的指针变量，int就是它的基类型</li>
</ul>
<h3 id="2-7-3-指针与数组"><a href="#2-7-3-指针与数组" class="headerlink" title="2.7.3 指针与数组"></a>2.7.3 指针与数组</h3><ul>
<li>数组由地址上连续的若干个相同类型的数据组合而成，可以在元素前面加取地址运算符&amp;来获取地址，如a[0]的地址是&amp;a[0]</li>
<li>c语言中数组名称也作为数组的首地址使用，即a == &amp;a[0]。若a为数组，可做赋值int* p = a，等同于int* p = &amp;a[0]</li>
<li>由于指针变量可以进行加减法，则a+i等同于&amp;a[i]，但a+i只是地址，想要访问a[i]需要用*(a+i)才和a[i]等价<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数组元素赋值</span><br><span class="line">scanf(&quot;%d&quot;, a+i);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-7-4-使用指针变量作为函数参数"><a href="#2-7-4-使用指针变量作为函数参数" class="headerlink" title="2.7.4 使用指针变量作为函数参数"></a>2.7.4 使用指针变量作为函数参数</h3><ul>
<li>视为把变量的地址传入函数，如果在函数中对这个地址中的元素进行改变，原先的数据就会确实的改变，这种传递方式称为地址传递<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 下面写法是错误的，因为temp没有被赋初值，指针变量temp中存放的地址若指向系统工作区间会出错，修改方法是给temp赋初值，或者把它定义为int型变量</span><br><span class="line">void swap(int* a, int* b)&#123;</span><br><span class="line">	int* temp;</span><br><span class="line">	*temp &#x3D; *a;</span><br><span class="line">	*a &#x3D; *b;</span><br><span class="line">	*b &#x3D; *temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># swap函数中直接交换a和b的地址并不能对main函数中的值进行交换，因为main函数传给swap函数的地址其实是一个无符号整型的数，其本身也和普通变量一样是值传递。修改方法是使用2.7.5节中的引用</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-7-5-引用"><a href="#2-7-5-引用" class="headerlink" title="2.7.5 引用"></a>2.7.5 引用</h3><ul>
<li>c++中的这个功能使函数中不使用指针也能修改传入参数，函数中不产生副本，相当于给原变量起了个别名，对引用变量的操作就是对原变量的操作</li>
<li>常量不可以使用引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 在函数参数类型后加&amp;即可，函数的参数名和实际传入的参数名可以不同</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void change(int &amp;a)&#123;</span><br><span class="line">	a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int x &#x3D; 10;</span><br><span class="line">	change(x);</span><br><span class="line">	printf(&quot;%d\n&quot;, x);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-8-结构体struct的使用"><a href="#2-8-结构体struct的使用" class="headerlink" title="2.8 结构体struct的使用"></a>2.8 结构体struct的使用</h2><h3 id="2-8-1-结构体的定义"><a href="#2-8-1-结构体的定义" class="headerlink" title="2.8.1 结构体的定义"></a>2.8.1 结构体的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># studentInfo是结构体的名字，内部是单个学生的信息，大括号外是studentInfo类型的Alice和Bob两个结构体变量，stu[100]是有很多学生时定义的一个结构体数组，如果此处不定义变量，则大括号外直接加分号</span><br><span class="line">struct studentInfo&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char gender; &#x2F;&#x2F; &#39;F&#39; or &#39;M&#39;</span><br><span class="line">&#125;Alice, Bob, stu[100];</span><br><span class="line">studentInfo Tom;</span><br><span class="line"></span><br><span class="line"># 结构体中能定义除了自己本身之外的任何数据类型，也可以定义自身类型的指针变量</span><br><span class="line">struct node&#123;</span><br><span class="line">	node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-2-访问结构体内的元素"><a href="#2-8-2-访问结构体内的元素" class="headerlink" title="2.8.2 访问结构体内的元素"></a>2.8.2 访问结构体内的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct studentInfo&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char gender; &#x2F;&#x2F; &#39;F&#39; or &#39;M&#39;</span><br><span class="line">	studentInfo* next;</span><br><span class="line">&#125;stu, *p;</span><br><span class="line"></span><br><span class="line"># 访问stu中变量</span><br><span class="line">stu.id</span><br><span class="line">stu.next</span><br><span class="line"></span><br><span class="line"># 访问指针变量p中元素</span><br><span class="line">(*p).id</span><br><span class="line">(*p).next</span><br><span class="line"></span><br><span class="line"># 访问指针变量p中元素</span><br><span class="line">p-&gt;id</span><br><span class="line">p-&gt;next</span><br></pre></td></tr></table></figure>

<h3 id="2-8-3-结构体的初始化"><a href="#2-8-3-结构体的初始化" class="headerlink" title="2.8.3 结构体的初始化"></a>2.8.3 结构体的初始化</h3><ul>
<li>方法一：逐一赋值如stu.id = 1;</li>
<li>方法二：读入时赋值如scanf(“%d”, &amp;stu.id)</li>
<li>方法三：构造函数，即用来初始化结构体的一种函数，直接定义在结构体中，不需要写返回类型，函数名与结构体名相同<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4></li>
<li>普通定义的结构体内部会生成一个默认的构造函数但它不可见，在上文定义的结构体中默认生成的构造函数是studentInfo(){}，由于这个构造函数的存在，才可以直接定义studentInfo类型的变量而不进行初始化(因为它没有让用户提供任何初始化参数)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 如果想自己手动提供id和gender的初始化参数，可在结构体中做如下定义</span><br><span class="line"># _id是变量名，只要不和已有的变量冲突，用什么变量名都可以</span><br><span class="line">struct studentInfo&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char gender;</span><br><span class="line"></span><br><span class="line">	studentInfo(int _id, char _gender)&#123;</span><br><span class="line">		id &#x3D; _id;</span><br><span class="line">		gender &#x3D; _gender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 也可以简化为一行</span><br><span class="line">struct studentInfo&#123;</span><br><span class="line">	int idl</span><br><span class="line">	char gender;</span><br><span class="line">	studentInfo(int_id, char_gender): id(_id), gender(_gender) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 这样可以在需要时直接对结构体变量进行赋值</span><br><span class="line">studentInfostu &#x3D; studentInfo(10086, &#39;M&#39;);</span><br><span class="line"></span><br><span class="line"># 如果自己重新定义了构造函数，则不能不经过初始化就定义结构体变量，因为此时默认生成的构造函数studentInfo()&#123;&#125;被覆盖了。可以手动加上来解决这个问题，也就是说只要参数个数和类型不完全相同，就可以定义多个构造函数来适应不同的初始化场合</span><br><span class="line"></span><br><span class="line"># 一个应用实例，结构体Point用于存放平面点的坐标x、y</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">struct Point&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	Point()&#123;&#125; &#x2F;&#x2F; 用来不经初始化的定义pt[10]</span><br><span class="line">	Point(int _x): x(_x) &#123;&#125; &#x2F;&#x2F; 用来提供x的初始化</span><br><span class="line">	Point(int _x, int_y): x(_x), y(_y) &#123;&#125; &#x2F;&#x2F; 用来提供x和y的初始化</span><br><span class="line">&#125;pt[10];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int num &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 1; i &lt;&#x3D; 3; i++)&#123;</span><br><span class="line">		for(int j &#x3D; 1; j &lt;&#x3D; 3; j++)&#123;</span><br><span class="line">			pt[num++] &#x3D; Point(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0; i &lt; num; i++)&#123;</span><br><span class="line">		printf(&quot;%d, %d\n&quot;, pt[i].x, pt[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-9-补充"><a href="#2-9-补充" class="headerlink" title="2.9 补充"></a>2.9 补充</h2><h3 id="2-9-1-cin与cout"><a href="#2-9-1-cin与cout" class="headerlink" title="2.9.1 cin与cout"></a>2.9.1 cin与cout</h3><ul>
<li>需要添加#include <iostream>和using namespace std;才能使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 不需要指定格式，不需要加&amp;，直接写变量名就可以了</span><br><span class="line"># 下面的代码根据代码前面的定义读入或输出了int型变量n、double型变量db、char型变量c、char型数组str[]等</span><br><span class="line"># 注意cout输出时中间没有空格，可以自己加上</span><br><span class="line">cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; &quot;&quot; &lt;&lt; db &lt;&lt; c &lt;&lt; str &lt;&lt; &quot;haha&quot;;</span><br><span class="line"></span><br><span class="line"># 读入一整行需要getline函数，下面的代码把一整行都读入char型数组str[100]中</span><br><span class="line">char str[100];</span><br><span class="line">cin.getline(str, 100); &#x2F;&#x2F; 100为读入字符的个数</span><br><span class="line"></span><br><span class="line"># string型容器的输入</span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line"></span><br><span class="line"># cout的换行方式</span><br><span class="line">cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line"># 或</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"># 如果想要控制输出格式，如控制double型的精度，需要加#include &lt;iomanip&gt;</span><br><span class="line"># 下面的代码会输出123.46</span><br><span class="line">cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; 123.4567 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li>由于cin和cout在输入输出大量数据时表现糟糕，所以还是建议使用scanf和printf，不得已时除外(如string容器)</li>
</ul>
<h3 id="2-9-2-浮点数的比较"><a href="#2-9-2-浮点数的比较" class="headerlink" title="2.9.2 浮点数的比较"></a>2.9.2 浮点数的比较</h3><ul>
<li>浮点数在计算机中的存储并不总是精确的，如3.14可能存储为3.1400001或者3.1399999，这样不利于判等，所以需要引入一个极小数eps来对这种误差进行修正</li>
<li>如果一个数a落在了[b-eps, b+eps]区间，就应当判等，经验表示eps取1e-8合适</li>
<li>可能一个变量中存储的0是个很小的负数，这时对它开根号会出错，asin(x)当x存放+1、acos(x)当x存放-1也是，这时需要使用eps使变量保证在定义域内</li>
<li>有时由于编译原因，原本为0.00的变量输出时会变为-0.00，这时需要把结果存放在字符串中，然后与0.00进行比较，如果比对成功则加上eps来修正为0.00<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 为了使用方便可以把比较操作写成宏定义的形式</span><br><span class="line"># 如果想使用不等于，只需要在使用时的Equ前面加一个非运算符&quot;!&quot;即可</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">#define Equ(a, b) ((fabs((a) - (b))) &lt; (eps))</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	double db &#x3D; 1.23;</span><br><span class="line">	if(Equ(db, 1.23))&#123;</span><br><span class="line">		printf(&quot;true&quot;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		printf(&quot;false&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 判断a &gt; b</span><br><span class="line">#define More(a, b) (((a) - (b)) &gt; (eps));</span><br><span class="line"></span><br><span class="line"># 判断a &gt;&#x3D; b</span><br><span class="line">#define MoreEqu(a, b) (((a) - (b)) &gt; (-eps));</span><br><span class="line"></span><br><span class="line"># pi的定义</span><br><span class="line">const double Pi &#x3D; acos(-1.0);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-9-3-复杂度"><a href="#2-9-3-复杂度" class="headerlink" title="2.9.3 复杂度"></a>2.9.3 复杂度</h3><ul>
<li>时间复杂度<ul>
<li>基本运算是类似加减乘除这种计算机可以直接实现的运算</li>
<li>高等级的幂次会覆盖低等级的幂次</li>
<li>有些算法实现较为复杂时，即使时间复杂度和其他同时间复杂度等级算法相同，性能也会有较大差距</li>
<li>一般的OJ系统，一秒能承受的运算次数大概是1e7-1e8，因此当O(n^2)的算法n的规模是1000时是可承受的</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>有与时间复杂度类似的写法，例如一个算法消耗的最大数据空间是一个二维数组时其空间复杂度是O(N^2)</li>
<li>一般来说空间够用，只要不开好几个1e7以上的数组即可</li>
<li>由于空间一般够用，所以常常用空间换时间</li>
</ul>
</li>
<li>编码复杂度：代码量</li>
</ul>
<h2 id="2-10-黑盒测试"><a href="#2-10-黑盒测试" class="headerlink" title="2.10 黑盒测试"></a>2.10 黑盒测试</h2><ul>
<li>黑盒测试：系统后台准备若干组数据让提交的程序去运行，如果输出结果完全正确(字符串意义的正确)，就称通过了黑盒测试，否则会根据错误类型而返回不同结果。根据黑盒测试是否对每组测试数据都单独测试或是一次性测试所有数据，可以分为单点测试和多点测试</li>
</ul>
<h3 id="2-10-1-单点测试"><a href="#2-10-1-单点测试" class="headerlink" title="2.10.1 单点测试"></a>2.10.1 单点测试</h3><ul>
<li>总得分等于通过的数据的分值之和</li>
<li>本书中程序均为单点测试</li>
<li>单点测试只需要对一组数据能够完整执行即可</li>
</ul>
<h3 id="2-10-2-多点测试"><a href="#2-10-2-多点测试" class="headerlink" title="2.10.2 多点测试"></a>2.10.2 多点测试</h3><ul>
<li>这种方式才能严格考验代码是否严谨</li>
<li>必须保证程序有办法反复执行代码的核心部分，这就要用到循环。一般有三种输入方式<h4 id="while…EOF"><a href="#while…EOF" class="headerlink" title="while…EOF"></a>while…EOF</h4></li>
<li>如果没有给定输入的结束条件，默认读取到文档末尾，黑盒测试所有输入数据放在一个文件中。</li>
<li>scanf函数的返回值为其成功读入的参数的个数。scanf对正常的控制台(屏幕黑框)输入一般不会失败，只有在读取文件时到达文件末尾导致的无法读取现象才会产生读入失败，这是scanf会返回-1，c语言中用EOF(end of file)来代表-1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当题目没有说有多少数据需要读入时，用scanf的返回值是否为EOF来判断输入是否结束</span><br><span class="line">&#x2F;&#x2F; %d可以根据输入格式改变</span><br><span class="line">&#x2F;&#x2F; 在控制台中需要手动触发EOF，即ctrl+z，这时会显示一个^Z,，按enter键即可结束while</span><br><span class="line">while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果用gets读入字符串，可以写做</span><br><span class="line">while(gets(str) !&#x3D; NULL)&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="while…break"><a href="#while…break" class="headerlink" title="while…break"></a>while…break</h4><ul>
<li>要求是当输入的数据满足某个条件时停止输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 有两种写法</span><br><span class="line">&#x2F;&#x2F; 写法一：在while…EOF的内部进行判断</span><br><span class="line">while(scanf(&quot;%d%d&quot;, &amp;a, &amp;b) !&#x3D; EOF)&#123;</span><br><span class="line">	if(a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0) break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二：把退出条件的判断放在while语句中</span><br><span class="line">while(scanf(&quot;%d%d&quot;, &amp;a, &amp;b), a || b)&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="while-T–-型"><a href="#while-T–-型" class="headerlink" title="while(T–)型"></a>while(T–)型</h4><ul>
<li><p>给出测试数据的组数和相应数量组数的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 总组数为T</span><br><span class="line">while(T--)&#123;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多点测试还有三种输出方式</p>
<ul>
<li>第一种：输出是连续的多行</li>
<li>第二种：每组数据输出后加额外一个空行</li>
<li>第三种：两组输出数据间有一个空行，最后一组数据后没有空行，这种一般是在while(T–)的输入情况下，只需要判断T是否已经减小到0来判断是否应当输出额外的换行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(T &gt; 0) printf(&quot;\n&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注意多点测试中，每一次循环都要重置一下变量和数组，否则在下一组数据运行时变量和数据就不是初始状态了，重置数组一般使用memset函数或fill函数</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%E9%99%84%E5%BD%95C-7/" rel="next" title="计算机体系结构量化研究方法附录C.7">
      计算机体系结构量化研究方法附录C.7 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">C&#x2F;C++快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2.1 基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.2.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F%E5%92%8Cconst%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">符号常量和const常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.4.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">2.2 顺序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">赋值表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8scanf%E5%92%8Cprintf%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用scanf和printf输入和输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8getchar%E5%92%8Cputchar%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">使用getchar和putchar输入输出字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.3.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef"><span class="nav-number">1.3.5.</span> <span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8math%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.</span> <span class="nav-text">常用math函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">2.3 选择结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.4.1.</span> <span class="nav-text">if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.4.2.</span> <span class="nav-text">switch语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">2.4 循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.1.</span> <span class="nav-text">while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-while%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">do while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.3.</span> <span class="nav-text">for语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.4.</span> <span class="nav-text">break和continue语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.</span> <span class="nav-text">2.5 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.1.</span> <span class="nav-text">2.5.1 一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">2.5.2 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.3.</span> <span class="nav-text">2.5.3 二维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-memset%E2%80%94%E2%80%94%E5%AF%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E8%B5%8B%E7%9B%B8%E5%90%8C%E7%9A%84%E5%80%BC"><span class="nav-number">1.6.4.</span> <span class="nav-text">2.5.4 memset——对数组中每个元素赋相同的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-5-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.5.</span> <span class="nav-text">2.5.5 字符数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-6-string-h%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.6.6.</span> <span class="nav-text">2.5.6 string.h头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-7-sscanf%E4%B8%8Espintf"><span class="nav-number">1.6.7.</span> <span class="nav-text">2.5.7 sscanf与spintf</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.</span> <span class="nav-text">2.6 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.7.1.</span> <span class="nav-text">2.6.1 函数的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E4%BB%A5%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.2.</span> <span class="nav-text">2.6.3 以数组作为函数参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E6%8C%87%E9%92%88"><span class="nav-number">1.8.</span> <span class="nav-text">2.7 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88"><span class="nav-number">1.8.1.</span> <span class="nav-text">2.7.1 什么是指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-number">1.8.2.</span> <span class="nav-text">2.7.2 指针变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">1.8.3.</span> <span class="nav-text">2.7.3 指针与数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-4-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.8.4.</span> <span class="nav-text">2.7.4 使用指针变量作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-5-%E5%BC%95%E7%94%A8"><span class="nav-number">1.8.5.</span> <span class="nav-text">2.7.5 引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E7%BB%93%E6%9E%84%E4%BD%93struct%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.</span> <span class="nav-text">2.8 结构体struct的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.9.1.</span> <span class="nav-text">2.8.1 结构体的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.9.2.</span> <span class="nav-text">2.8.2 访问结构体内的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.9.3.</span> <span class="nav-text">2.8.3 结构体的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">构造函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-%E8%A1%A5%E5%85%85"><span class="nav-number">1.10.</span> <span class="nav-text">2.9 补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-1-cin%E4%B8%8Ecout"><span class="nav-number">1.10.1.</span> <span class="nav-text">2.9.1 cin与cout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.10.2.</span> <span class="nav-text">2.9.2 浮点数的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-3-%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.10.3.</span> <span class="nav-text">2.9.3 复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="nav-number">1.11.</span> <span class="nav-text">2.10 黑盒测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-1-%E5%8D%95%E7%82%B9%E6%B5%8B%E8%AF%95"><span class="nav-number">1.11.1.</span> <span class="nav-text">2.10.1 单点测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-2-%E5%A4%9A%E7%82%B9%E6%B5%8B%E8%AF%95"><span class="nav-number">1.11.2.</span> <span class="nav-text">2.10.2 多点测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#while%E2%80%A6EOF"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">while…EOF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while%E2%80%A6break"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">while…break</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while-T%E2%80%93-%E5%9E%8B"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">while(T–)型</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">superran</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chaoranli20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chaoranli20" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fab fa-angellist"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">superran</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
